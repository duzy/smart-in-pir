# $Id$

=begin overview

This is the grammar for smart written as a sequence of Perl 6 rules.

=end overview

=cut

grammar smart::Grammar is PCT::Grammar;

rule TOP {
    {*}					#= enter
    <statement>*
    [ $ || <.panic: 'Unsupported statement'> ]
    {*}					#= leave
}

#token wb { \s }
token ws { <!ww> [ <comment> | \s+ ]* }
token comment { [ '#' '{' <-[ '}' ]>* '}' ] | [ '#' \N* \n? ] }

rule statement {
    | <makefile_variable_declaration> {*}	#= makefile_variable_declaration
    | <smart_say_statement> {*}			#= smart_say_statement
}

rule makefile_variable_declaration {
    <makefile_variable>
    <makefile_variable_assign>
    <makefile_variable_value_list>
    {*}
}
token makefile_variable {
    [ <-[ ':' '=' '#' \s ]> <-[ ':' '=' '#' '+' '?' ]>* ]
    {*}
}
#    [ <-[ ':' '=' '#' ' ' \t ]> <-[ ':' '=' '#' ]>* ]
#    [ $ || <.panic: 'Invalid makefile-variable identifier'> ]
token makefile_variable_assign { '=' | ':=' | '?=' | '+=' }
token makefile_variable_value_list {
    [
      |[
         [ <makefile_variable_value_item>* \\
           [ \n || <.panic: 'Suspicious continuation'> ]
           ]+
           <makefile_variable_value_item>*
           [ \n || <.panic: 'Expecting a new line'> ]
         ]
      |[ <makefile_variable_value_item>*
         [ \n || <.panic: 'Expecting a new line'> ]
         ]
    ] {*}
}
#token makefile_variable_value_item { <-[ \\ \n ]>+ {*} }
#token makefile_variable_value_item { [\S|\N|<-[\\]>]+ {*} }
#token makefile_variable_value_item { <[A..Za..z0..9\-\.]>+ {*} }

rule smart_say_statement {
    # used to output some messages.
    'say' <expression> [ ',' <expression> ]*
    [ ';' || <.panic: 'Requires statement terminater'> ]
    {*}
}

##  terms
token term {
    | <value> {*}                                #= value
    | <makefile_variable_method_call> {*}   #= makefile_variable_method_call
    | <makefile_variable_ref> {*}		 #= makefile_variable_ref
}

rule value {
    | <integer> {*}                              #= integer
    | <quote> {*}                                #= quote
}

rule integer { \d+ {*} }

rule quote {
    [ \' <string_literal: '\'' > \' | \" <string_literal: '"' > \" ]
    {*}
}

rule makefile_variable_method_call {
    <makefile_variable_ref> '.' <ident>
        '(' [ <expression> [ ',' <expression> ]* ]?
        [ ')' || <.panic: "Require an ')' to terminate parameter list"> ]
    {*}
}

rule makefile_variable_ref {
    | <makefile_variable_ref1> {*}	#= makefile_variable_ref1
    | <makefile_variable_ref2> {*}	#= makefile_variable_ref2
}
rule makefile_variable_ref1 {
    '$'
    [ '(' <makefile_variable_name1>
    [ ')' || <.panic: "Makefile variable-referencing expects ')'"> ]]
    {*}
}
rule makefile_variable_ref2 {
    '$'
    [ '{' <makefile_variable_name2>
    [ '}' || <.panic: "Makefile variable-referencing expects '}'"> ]]
    {*}
}
token makefile_variable_name1 { <-[')']>+ }
token makefile_variable_name2 { <-['}']>+ }

rule expression is optable { ... }



######################################################################
##  expressions and operators
proto 'term:'     is precedence('=')     is parsed(&term)      { ... }

## multiplicative operators
proto infix:<*>   is looser(term:)       is pirop('mul')     { ... }
proto infix:</>   is equiv(infix:<*>)    is pirop('div')     { ... }

## additive operators
proto infix:<+>   is looser(infix:<*>)   is pirop('add')     { ... }
proto infix:<->   is equiv(infix:<+>)    is pirop('sub')     { ... }
######################################################################

