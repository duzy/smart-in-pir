# $Id$

=begin overview

This is the grammar for smart written as a sequence of Perl 6 rules.

=end overview

=cut

grammar smart::Grammar is PCT::Grammar;

rule TOP {
    {*}					#= enter
    <statement>*
    [ $ || <.panic: 'smart: * Unsupported Statement'> ]
    {*}					#= leave
}

#token wb { \s }
token ws { <!ww> [ <comment> | \s+ ]* }
token comment { [ '#{' <-[ } ]>* '}' ] | [ '#' \N* \n? ] }

rule statement {
    | <empty_smart_statement> {*}               #= empty_smart_statement
    | <smart_say_statement> {*}			#= smart_say_statement
    | <makefile_variable_declaration> {*}	#= makefile_variable_declaration
    | <makefile_rule> {*}                       #= makefile_rule
}

token empty_smart_statement { <.ws> ';' {*} }

token makefile_variable_declaration {
    <makefile_variable>
    <makefile_variable_assign> 
    <makefile_variable_value_list>
    [ [\n | $] || <.panic: 'smart: * Makefile variable declaration expecting end of line'> ]
    {*}
}
token makefile_variable {
      <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*
      {{
      $S0 = match.'text'()
      $I0 = length $S0
      $I1 = $I0 - 1
      loop:
      unless 0 <= $I1 goto end
      $S1 = substr $S0, $I1, 1
      if $S1 != ' ' goto loop_end
      dec $I1
      goto loop
      loop_end:
      if $I0 <= 0 goto end
      $I2 = match.'from'()
      $I2 = $I2 + $I1
      match.'to'( $I2 )
      end:

      #print "var: "
      #print " '"
      #$S0 = match.'text'()
      #print $S0
      #print "'\n"
      }}
}
token makefile_variable_assign { [ '=' | ':=' | '?=' | '+=' ] }
token makefile_variable_value_list {
    [
      |[ <[ \ \t ]>*
         [ [ <makefile_variable_value_item> <[ \ \t ]>* ]* \\
           [ \n || <.panic: 'smart: * Suspicious continuation'> ]
         ]+
         <[ \ \t ]>*
         [ <makefile_variable_value_item> <[ \ \t ]>* ]*
       ]
      |[ <[ \ \t ]>*
         [ <makefile_variable_value_item> <[ \ \t ]>* ]*
       ]
    ]
    
#    {{
#    $S0 = match.'text'()
#    print "value: '"
#    print $S0
#    print "'\n"
#    }}
}
token makefile_variable_value_item { <-[ \ \t \\ \n ]>+ }

token makefile_rule {
    <makefile_targets> <[ \ \t ]>* ':' <[ \ \t ]>*
    [ <makefile_prerequisite> <[ \ \t ]>* ]*
    [
     |[ ';' <[ \ \t ]>* <makefile_rule_action>
        [ \n \t <makefile_rule_action> ]*
      ]
     |[ \n \t <makefile_rule_action> ]*
     |[ <.panic: "smart: * Bad rule format"> ]
    ]
    {*}
}
token makefile_targets { [ <makefile_target> <[ \ \t ]>* ]+ }
token makefile_target { <-[ : \ \t \n ]>+ }
token makefile_prerequisite {
    | <makefile_variable_ref> {*}
    | <-[ ; \ \t \n ]>+ {*}
}
token makefile_rule_action { <-[ \n ]>* {*} }

rule smart_say_statement {
    'say' <expression> [ ',' <expression> ]*
    [ ';' || <.panic: 'smart: * Unterminated statement'> ]
    {*}
}

##  terms
token term {
    | <value> {*}                                #= value
    | <makefile_variable_method_call> {*}        #= makefile_variable_method_call
    | <makefile_variable_ref> {*}		 #= makefile_variable_ref
}

rule value {
    | <integer> {*}                              #= integer
    | <quote> {*}                                #= quote
}

rule integer { \d+ {*} }

rule quote {
    [ \' <string_literal: '\'' > \' | \" <string_literal: '"' > \" ]
    {*}
}

rule makefile_variable_method_call {
    <makefile_variable_ref> '.' <ident>
        '(' [ <expression> [ ',' <expression> ]* ]?
        [ ')' || <.panic: "smart: * Require an ')' to terminate parameter list"> ]
    {*}
}

token makefile_variable_ref {
    | <makefile_variable_ref1> {*}
    | <makefile_variable_ref2> {*}
}
token makefile_variable_ref1 {
    '$'
    [ '(' <makefile_variable_name1>
    [ ')' || <.panic: "smart: * Makefile variable referencing expects ')'"> ]]
}
token makefile_variable_ref2 {
    '$'
    [ '{' <makefile_variable_name2>
    [ '}' || <.panic: "smart: * Makefile variable referencing expects '}'"> ]]
}
token makefile_variable_name1 { <-[ ) \n : = # ]>+ }
token makefile_variable_name2 { <-[ } \n : = # ]>+ }

rule expression is optable { ... }



######################################################################
##  expressions and operators
proto 'term:'     is precedence('=')     is parsed(&term)      { ... }

## multiplicative operators
proto infix:<*>   is looser(term:)       is pirop('mul')     { ... }
proto infix:</>   is equiv(infix:<*>)    is pirop('div')     { ... }

## additive operators
proto infix:<+>   is looser(infix:<*>)   is pirop('add')     { ... }
proto infix:<->   is equiv(infix:<+>)    is pirop('sub')     { ... }
######################################################################

