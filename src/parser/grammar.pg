# $Id$

=begin overview

This is the grammar for smart written as a sequence of Perl 6 rules.

=end overview

=cut

grammar smart::Grammar is PCT::Grammar;

rule TOP {
    {*}					#= enter
    <statement>*
    [ $ || <.panic: 'smart: * Unsupported statement'> ]
    {*}					#= leave
}

token ws { <!ww> [ <comment> | \s+ ]* }
token comment { <comment_block> | [ '#' \N* \n? ] }
token comment_block { '#{' <-[ } ]>* '}' }
token ws_inline { <!ww> [ <comment_block> | <[ \ \t ]>* | [ '#' \N* ] ] }

rule statement {
    | <empty_smart_statement> {*}               #= empty_smart_statement
    | <smart_builtin_statement> {*}		#= smart_builtin_statement
    | <smart_builtin_function> {*}              #= smart_builtin_function
    | <make_variable_declaration> {*}	#= make_variable_declaration
    | <make_rule> {*}                       #= make_rule
    | <make_conditional_statement> {*}      #= make_conditional_statement
    | <make_include_statement> {*}          #= make_include_statement
}

token empty_smart_statement { <.ws> ';' {*} }

token make_variable_declaration {
    [ $<override>=['override'] <.ws> ]?
    [
      |[ $<sign>=['define'] <[ \ \t ]>+ <.ws_inline>
         $<name>=[ <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*: ] <.ws_inline> \n
         $<value>=[ [<!before [\n'endef'|'endef']> .]* ] \n?
         'endef' <.ws_inline> \n
       ]
      |[ $<name>=[ <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*: ]
         $<sign>=[ '=' | ':=' | '?=' | '+=' ]
         <make_variable_value_list>
         [ [\n | $] || <.panic: 'smart: * Unterminated makefile variable declaration'> ]
       ]
    ] {*}
}
#token make_variable {
#    <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*
#    {{
#      $S0 = match.'text'()
#      $I0 = length $S0
#      $I1 = $I0 - 1
#      loop:
#      unless 0 <= $I1 goto end
#      $S1 = substr $S0, $I1, 1
#      if $S1 != ' ' goto loop_end
#      dec $I1
#      goto loop
#      loop_end:
#      if $I0 <= 0 goto end
#      $I2 = match.'from'()
#      $I2 = $I2 + $I1
#      match.'to'( $I2 )
#      end:
#            
#      #print "var: "
#      #print " '"
#      #$S0 = match.'text'()
#      #print $S0
#      #print "'\n"
#    }}
#}
token make_variable_value_list {
    [
      <.ws_inline> [\\\n]?
      [ $<item>=[<-[ \\ \n ]>+] [\\\n]? ]*
    ]
}
# token make_variable_value_list {
#     [
#       |[ 
#          [ <.ws_inline>
#            [[
#               | $<item>=[<-[ \ \t \\ \n $ ]>* '$(' <-[)]>+ ')']
#               | $<item>=[<-[ \ \t \\ \n $ ]>* '${' <-[)]>+ '}']
#               | $<item>=[\" <-[ \" ]>+ \"]
#               | $<item>=[\' <-[ \' ]>+ \']
#               | $<item>=[<-[ \ \t \\ \n ]>+]
#             ]
#             <.ws_inline> ]* \\
#            [ \n || <.panic: 'smart: * Suspicious continuation'> ]
#          ]+
#          <.ws_inline>
#          [[
#             | $<item>=[<-[ \ \t \\ \n $ ]>* '$(' <-[)]>+ ')']
#             | $<item>=[<-[ \ \t \\ \n $ ]>* '${' <-[)]>+ '}']
#             | $<item>=[\" <-[ \" ]>+ \"]
#             | $<item>=[\' <-[ \' ]>+ \']
#             | $<item>=[<-[ \ \t \\ \n ]>+]
#           ]
#           <.ws_inline> ]*
#        ]
#       |[ <.ws_inline>
#          [[
#             | $<item>=[[<-[ \ \t \\ \n $ ]>* '$(' <-[)]>+ ')']+]
#             | $<item>=[[<-[ \ \t \\ \n $ ]>* '${' <-[)]>+ '}']+]
#             | $<item>=[\" <-[ \" ]>+ \"]
#             | $<item>=[\' <-[ \' ]>+ \']
#             | $<item>=[<-[ \ \t \\ \n ]>+]
#           ]
#           <.ws_inline> ]*
#        ]
#     ]
# }

token make_rule {
    |[ <make_special_rule> ] {*}
    |[ [
         |[ $<static_targets>=[ [ <make_target> <.ws_inline> ]+ ]
            ':' <.ws_inline>
            $<target_pattern>=[<-[ : \n ]>+]
            ':' <.ws_inline>
            $<prereq_pattern>=[<-[ \\ \n ]>+]
            [\\\n <.ws_inline>]?
          ]
         |[ $<targets>=[ [ <make_target> <.ws_inline> ]+ ]
            ':' <.ws_inline> [\\\n <.ws_inline>]?
            [<make_prerequisite><.ws_inline>[\\\n<.ws_inline>]?]*
            [ '|' <.ws_inline> <order_only_prerequisites> ]?
          ]
       ]
       [
         |[ ';' <.ws_inline> <make_rule_action>
            [ \n \t <make_rule_action> ]*
          ]
         |[
            [ \n <[ \ ]>* [ [ '#' \N* ] | <.comment_block> ] ]*
            [ \n \t <make_rule_action> ]*
          ]
       ]
     ] {*}
}
#      $<item>=[ <make_variable_ref> | [<-[ : \ \t \n ]>+] ]
token make_target {
#     | <make_variable_ref> {*}
#     | <-[ : \ \t \n ]>+ {*}
    [<make_variable_ref>|<-[:\ \t\n$]>]+ {*}
}
token make_prerequisite {
#     | <make_variable_ref> {*}
#     | <-[ ; \ \t \\ \n ]>+ {*}
    [<make_variable_ref>|<-[;|\ \t\\\n$]>]+ {*}
}
#    <?after '|' <.ws_inline> >
token order_only_prerequisites {
    [<make_prerequisite><.ws_inline>[\\\n <.ws_inline>]?]*
    {*}
}
token make_rule_action {
    [[<!before \\\n><-[\n]>]+ [\\\n]?]* {*}
}
token make_special_rule {
    <.ws_inline>
    [
    | $<name>=[ '.PHONY' ]
    | $<name>=[ '.SUFFIXES' ]
    | $<name>=[ '.DEFAULTS' ]
    | $<name>=[ '.PRECIOUS' ]
    | $<name>=[ '.INTERMEDIATE' ]
    | $<name>=[ '.SECONDARY' ]
    | $<name>=[ '.SECONDEXPANSION' ]
    | $<name>=[ '.DELETE_ON_ERROR' ]
    | $<name>=[ '.IGNORE' ]
    | $<name>=[ '.LOW_RESOLUTION_TIME' ]
    | $<name>=[ '.SILENT' ]
    | $<name>=[ '.EXPORT_ALL_VARIABLES' ]
    | $<name>=[ '.NOTPARALLEL' ]
    ]
    <.ws_inline>
    ':'
    [ <.ws_inline> $<item>=[ <-[ \n \t \ ]>+ ] ]*
    <.ws_inline>
    \n {*}
}

rule make_conditional_statement {
    $<csta>=['ifeq'|'ifneq']
    [
      |[ '('
         $<arg1>=[[<-[,)$]>|<.make_variable_ref>]*]
         ','
         $<arg2>=[[<-[)$]>|<.make_variable_ref>]*]
         ')'
       ]
      |[ | \' $<arg1>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg1>=[<-[ " ]>*] \" <[ \ \t ]>* ]
       [ | \' $<arg2>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg2>=[<-[ " ]>*] \" <[ \ \t ]>* ]
    ]
    {{ '!push-makefile-variable-switch'( match ) }}
    <if_stat=statement>*
    [ 'else'
      {{
        get_hll_global $P0, ['smart';'Grammar';'Actions'], '$VAR_ON'
        $I0 = $P0
        $I0 = !$I0
        $P0 = $I0
        set_hll_global ['smart';'Grammar';'Actions'], '$VAR_ON', $P0
      }}
      <else_stat=statement>*
    ]*
    [ 'endif' {{ '!pop-makefile-variable-switch'(match) }}
      | <.panic: "smart: * No 'endif'">
    ]
    {*}
}

rule make_include_statement {
    'include' \N+
    {*}
}

rule smart_builtin_statement {
    $<name>=['say']
    <expression> [ ',' <expression> ]*
    [ ';' || <.panic: 'smart: * Unterminated statement'> ]
    {*}
}

rule smart_builtin_function {
    $<name>=['expand'|'subst'|'patsubst'|'strip'|'origin'|'match']
    '('
    <expression> [ ',' <expression> ]*
#    [ ';' || <.panic: 'smart: * Unterminated function'> ]
    ')'
    {*}
}

##  terms
token term {
    | <value> {*}                                #= value
    | <make_variable_method_call> {*}        #= make_variable_method_call
    | <make_variable_ref> {*}		 #= make_variable_ref
    | <smart_builtin_function> {*}               #= smart_builtin_function
}

rule value {
    | <integer> {*}                              #= integer
    | <quote> {*}                                #= quote
}

rule integer { \d+ {*} }

rule quote {
    [ \' <string_literal: '\'' > \' | \" <string_literal: '"' > \" ]
    {*}
}

rule make_variable_method_call {
    <make_variable_ref> '.' <ident>
        '(' [ <expression> [ ',' <expression> ]* ]?
        [ ')' || <.panic: "smart: * Require an ')' to terminate parameter list"> ]
    {*}
}

token make_variable_ref {
    [
     | <make_variable_ref1>
     | <make_variable_ref2>
    ]
    {*}
#    {{
#    $S0 = match.text()
#    say $S0
#    }}
}
token make_variable_ref1 {
    '$'
    [ '(' $<name>=[[<!before ')'><-[\n:=#$]>|<.make_variable_ref>]+]
    [ ')' || <.panic: "smart: * Make variable referencing expects ')'"> ]]
}
token make_variable_ref2 {
    '$'
    [ '{' $<name>=[[<!before '}'><-[\n:=#$]>|<.make_variable_ref>]+]
    [ '}' || <.panic: "smart: * Make variable referencing expects '}'"> ]]
}

rule expression is optable { ... }



######################################################################
##  expressions and operators
proto 'term:'     is precedence('=')     is parsed(&term)      { ... }

## multiplicative operators
proto infix:<*>   is looser(term:)       is pirop('mul')     { ... }
proto infix:</>   is equiv(infix:<*>)    is pirop('div')     { ... }

## additive operators
proto infix:<+>   is looser(infix:<*>)   is pirop('add')     { ... }
proto infix:<->   is equiv(infix:<+>)    is pirop('sub')     { ... }
######################################################################

