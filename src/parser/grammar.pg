# $Id$

=begin overview

This is the grammar for smart written as a sequence of Perl 6 rules.

=end overview

=cut

grammar smart::Grammar is PCT::Grammar;

rule TOP {
    {*}					#= enter
    <statement>*
    [ $ || <.panic: 'smart: * Unsupported statement'> ]
    {*}					#= leave
}

token ws { <!ww> [ <comment> | \s+ ]* }
token comment { <comment_block> | [ '#' \N* \n? ] }
token comment_block { '#{' <-[ } ]>* '}' }
token ws_inline { <!ww> [ <comment_block> | <[ \ \t ]>* | [ '#' \N* ] ] }

rule statement {
    | <smart_statement> {*}                     #= smart_statement
    | <make_variable_declaration> {*}           #= make_variable_declaration
    | <make_rule> {*}                           #= make_rule
    | <make_conditional_statement> {*}          #= make_conditional_statement
    | <make_include_statement> {*}              #= make_include_statement
}

rule smart_statement {
    | <empty_smart_statement> {*}               #= empty_smart_statement
    | <smart_builtin_statement> {*}		#= smart_builtin_statement
    | <smart_builtin_function> {*}              #= smart_builtin_function
}

token empty_smart_statement { <.ws> ';' {*} }

token make_variable_declaration {
    [ $<override>=['override'] <.ws> ]?
    [
      |[ $<sign>=['define'] <[ \ \t ]>+ <.ws_inline>
         $<name>=[ <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*: ] <.ws_inline> \n
         $<value>=[ [<!before [\n'endef'|'endef']> .]* ] \n?
         'endef' <.ws_inline> \n
       ]
      |[ $<name>=[ <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*: ]
         $<sign>=[ '=' | ':=' | '?=' | '+=' ] <.ws_inline> [\\\n]?
         [ $<item>=[<-[ \\ \n ]>+] [\\\n]? ]*
         [ [\n | $] || <.panic: 'smart: * Unterminated makefile variable declaration'> ]
       ]
    ] {*}
}
#token make_variable {
#    <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*
#    {{
#      $S0 = match.'text'()
#      $I0 = length $S0
#      $I1 = $I0 - 1
#      loop:
#      unless 0 <= $I1 goto end
#      $S1 = substr $S0, $I1, 1
#      if $S1 != ' ' goto loop_end
#      dec $I1
#      goto loop
#      loop_end:
#      if $I0 <= 0 goto end
#      $I2 = match.'from'()
#      $I2 = $I2 + $I1
#      match.'to'( $I2 )
#      end:
#            
#      #print "var: "
#      #print " '"
#      #$S0 = match.'text'()
#      #print $S0
#      #print "'\n"
#    }}
#}

token expandable {
    [
      |[ $<lp>=['$'] <-[({]> ]
      |[ $<lp>=['$('] <expanded_text>+ $<rp>=[')'] ]
      |[ $<lp>=['${'] <expanded_text>+ $<rp>=['}'] ]
    ]
    {*}
}
token expanded_text {
    [
      |[<expandable> $<suf>=[[<!before [')'|'$']><-[\n]>]+]]
      |[$<pre>=[[<!before [')'|'$']><-[\n]>]+] <expandable>]
      |<expandable>
      |$<all>=<-[$)\n]>+
    ]
    {*}
}

token expanded_targets {
    [
      |[ $<pre>=[[<!before [':']><-[\\\n$\ \t:;]>]+]
         <expandable>?
         $<suf>=[[<!before [':']><-[\\\n$\ \t:;]>]*]
       ]
      | <expandable>
    ]
    {*}
}

token make_rule {
    |[ <make_special_rule> ] {*}
    |[ <.ws_inline>
       [<expanded_targets><.ws_inline>[\\\n<.ws_inline>]*]+
       ':' <.ws_inline> [\\\n<.ws_inline>]*
       [
         |[
            <static_target_pattern>
            $<seccon>=[':'] <.ws_inline> [\\\n<.ws_inline>]*
            <static_prereq_pattern> [\\\n<.ws_inline>]*
          ]
         |[
            <expanded_prerequisites>
            [ '|' <.ws_inline> [\\\n<.ws_inline>]* <expanded_orderonly> ]?
          ]
       ]
       [
         |[ ';' <.ws_inline>
            [<smart_action> | [<make_action> [ \n \t <make_action> ]*]]
          ]
         |[ <smart_action>
            |[ [ \n <[ \ ]>* [ [ '#' \N* ] | <.comment_block> ] ]*
               [ \n \t <make_action> ]*
             ]
          ]
       ]
     ] {*}
}
token static_target_pattern {
    [<expanded_targets><.ws_inline>[\\\n<.ws_inline>]*]+
    {*}
}
token static_prereq_pattern {
    [<expanded_targets><.ws_inline>[\\\n<.ws_inline>]*]+
    {*}
}
token expanded_prerequisites {
    [<expanded_targets><.ws_inline>[\\\n<.ws_inline>]*]*
    {*}
}
token expanded_orderonly {
    [<expanded_targets><.ws_inline>[\\\n<.ws_inline>]*]*
    {*}
}
token make_prerequisite {
    [<make_variable_ref>|<-[(:;|\ \t\\\n$]>]+
    ['('<-[)]>*')']?
}
token make_prerequisite_oo {
    [<make_variable_ref>|<-[(:;|\ \t\\\n$]>]+
    ['('<-[)]>*')']?
}
token make_action {
    [[<!before \\\n><-[\n]>]+ [\\\n]?]*
}
rule smart_action {
    '{'
    <smart_statement>*
    '}'
    {*}
}
token make_special_rule {
    <.ws_inline>
    $<name>=[
    | '.PHONY'
    | '.SUFFIXES'
    | '.DEFAULTS'
    | '.PRECIOUS'
    | '.INTERMEDIATE'
    | '.SECONDARY'
    | '.SECONDEXPANSION'
    | '.DELETE_ON_ERROR'
    | '.IGNORE'
    | '.LOW_RESOLUTION_TIME'
    | '.SILENT'
    | '.EXPORT_ALL_VARIABLES'
    | '.NOTPARALLEL'
    ]
    <.ws_inline>
    ':' [ <.ws_inline> $<item>=[ <-[ \n \t \ ]>+ ] ]* <.ws_inline>
    [ \n\t[<!before [\\\n|\n]>.]*[\\\n<.ws_inline>]? ]*
    {*}
}

rule make_conditional_statement {
    $<csta>=['ifeq'|'ifneq']
    [
      |[ '('
         $<arg1>=[[<-[,)$]>|<.make_variable_ref>]*]
         ','
         $<arg2>=[[<-[)$]>|<.make_variable_ref>]*]
         ')'
       ]
      |[ | \' $<arg1>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg1>=[<-[ " ]>*] \" <[ \ \t ]>* ]
       [ | \' $<arg2>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg2>=[<-[ " ]>*] \" <[ \ \t ]>* ]
    ]
    {{
      $S0 = match['csta']
      $S1 = match['arg1']
      $S2 = match['arg2']
      $S1 = 'expand'( $S1 )
      $S2 = 'expand'( $S2 )
      get_hll_global $P0, ['smart';'Grammar';'Actions'], '$VAR_ON'
      get_hll_global $P1, ['smart';'Grammar';'Actions'], '@VAR_SWITCHES'
      push $P1, $P0 ## save the the previous $VAR_ON value
      $I0 = $S1 == $S2
      if $S0 == 'ifeq' goto update_flag
      $I0 = !$I0 # 'ifneq'
    update_flag:
      $P0 = new 'Integer'
      $P0 = $I0
      set_hll_global ['smart';'Grammar';'Actions'], '$VAR_ON', $P0
    }}
    <if_stat=statement>*
    [ 'else'
      {{
        get_hll_global $P0, ['smart';'Grammar';'Actions'], '$VAR_ON'
        $I0 = $P0
        $I0 = !$I0
        $P0 = $I0
        set_hll_global ['smart';'Grammar';'Actions'], '$VAR_ON', $P0
      }}
      <else_stat=statement>*
    ]*
    [ 'endif'
      {{
        get_hll_global $P1, ['smart';'Grammar';'Actions'], '@VAR_SWITCHES'
        pop $P0, $P1
        set_hll_global ['smart';'Grammar';'Actions'], '$VAR_ON', $P0
      }}
      | <.panic: "smart: * No 'endif'">
    ]
    {*}
}

rule make_include_statement {
    'include' \N+
    {*}
}

rule smart_builtin_statement {
    $<name>=['say']
    <expression> [ ',' <expression> ]*
    [ ';' || <.panic: 'smart: * Unterminated statement'> ]
    {*}
}

rule smart_builtin_function {
    $<name>=['expand'|'subst'|'patsubst'|'strip'|'origin'|'match']
    '('
    <expression> [ ',' <expression> ]*
#    [ ';' || <.panic: 'smart: * Unterminated function'> ]
    ')'
    {*}
}

##  terms
token term {
    | <value> {*}                               #= value
    | <make_variable_method_call> {*}           #= make_variable_method_call
    | <make_variable_ref> {*}                   #= make_variable_ref
    | <smart_builtin_function> {*}              #= smart_builtin_function
}

rule value {
    | <integer> {*}                              #= integer
    | <quote> {*}                                #= quote
}

rule integer { \d+ {*} }

rule quote {
    [ \' <string_literal: '\'' > \' | \" <string_literal: '"' > \" ]
    {*}
}

rule make_variable_method_call {
    <make_variable_ref> '.' <ident>
        '(' [ <expression> [ ',' <expression> ]* ]?
        [ ')' || <.panic: "smart: * Require an ')' to terminate parameter list"> ]
    {*}
}

token make_variable_ref {
    [
     | <make_variable_ref1>
     | <make_variable_ref2>
    ]
    {*}
#    {{
#    $S0 = match.text()
#    say $S0
#    }}
}
token make_variable_ref1 {
    '$'
    [ '(' $<name>=[[<!before ')'><-[\n:=#$]>|<.make_variable_ref>]+]
    [ ')' || <.panic: "smart: * Make variable referencing expects ')'"> ]]
}
token make_variable_ref2 {
    '$'
    [ '{' $<name>=[[<!before '}'><-[\n:=#$]>|<.make_variable_ref>]+]
    [ '}' || <.panic: "smart: * Make variable referencing expects '}'"> ]]
}

rule expression is optable { ... }



######################################################################
##  expressions and operators
proto 'term:'     is precedence('=')     is parsed(&term)      { ... }

## multiplicative operators
proto infix:<*>   is looser(term:)       is pirop('mul')     { ... }
proto infix:</>   is equiv(infix:<*>)    is pirop('div')     { ... }

## additive operators
proto infix:<+>   is looser(infix:<*>)   is pirop('add')     { ... }
proto infix:<->   is equiv(infix:<+>)    is pirop('sub')     { ... }
######################################################################

