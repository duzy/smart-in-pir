# $Id$

=begin overview

This is the grammar for smart written as a sequence of Perl 6 rules.

=end overview

=cut

grammar smart::Grammar is PCT::Grammar;

rule TOP {
    {*}					#= enter
    <statement>*
    [ $ || <.panic: 'smart: * Unsupported Statement'> ]
    {*}					#= leave
}

token ws { <!ww> [ <comment> | \s+ ]* }
token comment { <comment_block> | [ '#' \N* \n? ] }
token comment_block { '#{' <-[ } ]>* '}' }
token ws_inline { <!ww> [ <comment_block> | <[ \ \t ]>* | [ '#' \N* ] ] }

rule statement {
    | <empty_smart_statement> {*}               #= empty_smart_statement
    | <smart_say_statement> {*}			#= smart_say_statement
    | <makefile_variable_declaration> {*}	#= makefile_variable_declaration
    | <makefile_rule> {*}                       #= makefile_rule
    | <makefile_conditional_statement> {*}      #= makefile_conditional_statement
}

token empty_smart_statement { <.ws> ';' {*} }

token makefile_variable_declaration {
    $<name>=[ <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*: ]
    $<sign>=[ '=' | ':=' | '?=' | '+=' ]
    <makefile_variable_value_list>
    [ [\n | $] || <.panic: 'smart: * Unterminated makefile variable declaration'> ]
    {*}
}
#token makefile_variable {
#    <-[ : = # \ \t \n ]> <-[ : = # + ? \n ]>*
#    {{
#      $S0 = match.'text'()
#      $I0 = length $S0
#      $I1 = $I0 - 1
#      loop:
#      unless 0 <= $I1 goto end
#      $S1 = substr $S0, $I1, 1
#      if $S1 != ' ' goto loop_end
#      dec $I1
#      goto loop
#      loop_end:
#      if $I0 <= 0 goto end
#      $I2 = match.'from'()
#      $I2 = $I2 + $I1
#      match.'to'( $I2 )
#      end:
#            
#      #print "var: "
#      #print " '"
#      #$S0 = match.'text'()
#      #print $S0
#      #print "'\n"
#    }}
#}
token makefile_variable_value_list {
    [
      |[ 
         [ [ <[ \ \t ]> | <.comment> ]*
           [ $<item>=[<-[ \ \t \\ \n ]>+] <[ \ \t ]>* ]* \\
           [ \n || <.panic: 'smart: * Suspicious continuation'> ]
         ]+
         [ <[ \ \t ]> | <.comment> ]*
         [ $<item>=[<-[ \ \t \\ \n ]>+] <[ \ \t ]>* ]*
       ]
      |[ <[ \ \t ]>*
         [ $<item>=[<-[ \ \t \\ \n ]>+] <[ \ \t ]>* ]*
       ]
    ]
    
#    {{
#    $S0 = match.'text'()
#    print "value: '"
#    print $S0
#    print "'\n"
#    }}
}

token makefile_rule {
    |[ <makefile_special_rule> ] {*}
    |[ $<targets>=[ [ <makefile_target> <[ \ \t ]>* ]+ ]
       <[ \ \t ]>* ':' <[ \ \t ]>*
       [ <makefile_prerequisite> <[ \ \t ]>* ]*
       [
         |[ ';' <[ \ \t ]>* <makefile_rule_action>
            [ \n \t <makefile_rule_action> ]*
          ]
         |[
            [ \n <[ \ ]>* [ [ '#' \N* ] | <.comment_block> ] ]*
            [ \n \t <makefile_rule_action> ]*
          ]
       ]
     ] {*}
}
#      $<item>=[ <makefile_variable_ref> | [<-[ : \ \t \n ]>+] ]
token makefile_target {
    | <makefile_variable_ref> {*}
    | <-[ : \ \t \n ]>+ {*}
}
token makefile_prerequisite {
    | <makefile_variable_ref> {*}
    | <-[ ; \ \t \n ]>+ {*}
}
token makefile_rule_action { <-[ \n ]>* {*} }
token makefile_special_rule {
    <.ws_inline>
    [
    | $<name>=[ '.PHONY' ]
    | $<name>=[ '.SUFFIXES' ]
    | $<name>=[ '.DEFAULTS' ]
    | $<name>=[ '.PRECIOUS' ]
    | $<name>=[ '.INTERMEDIATE' ]
    | $<name>=[ '.SECONDARY' ]
    | $<name>=[ '.SECONDEXPANSION' ]
    | $<name>=[ '.DELETE_ON_ERROR' ]
    | $<name>=[ '.IGNORE' ]
    | $<name>=[ '.LOW_RESOLUTION_TIME' ]
    | $<name>=[ '.SILENT' ]
    | $<name>=[ '.EXPORT_ALL_VARIABLES' ]
    | $<name>=[ '.NOTPARALLEL' ]
    ]
    <.ws_inline>
    ':'
    [ <.ws_inline> $<item>=[ <-[ \n \t \ ]>+ ] ]*
    <.ws_inline>
    \n {*}
}

rule makefile_conditional_statement {
    $<csta>=['ifeq'|'ifneq']
    [
      |[ '('
         $<arg1>=[[<-[,)$]>|<.makefile_variable_ref>]*]
         ','
         $<arg2>=[[<-[)$]>|<.makefile_variable_ref>]*]
         ')'
       ]
      |[ | \' $<arg1>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg1>=[<-[ " ]>*] \" <[ \ \t ]>* ]
       [ | \' $<arg2>=[<-[ ' ]>*] \' <[ \ \t ]>*
         | \" $<arg2>=[<-[ " ]>*] \" <[ \ \t ]>* ]
    ]
    {{
      '!push-makefile-variable-switch'( match )
    }}
    <if_stat=statement>*
    [ 'else'
      {{
        get_hll_global $P0, ['smart';'Grammar';'Actions'], '$VAR_ON'
        $I0 = $P0
        $I0 = !$I0
        $P0 = $I0
        set_hll_global ['smart';'Grammar';'Actions'], '$VAR_ON', $P0
      }}
      <else_stat=statement>*
    ]*
    [ 'endif' {{ '!pop-makefile-variable-switch'(match) }}
      | <.panic: "smart: * No 'endif'">
    ]
    {*}
}

rule smart_say_statement {
    'say' <expression> [ ',' <expression> ]*
    [ ';' || <.panic: 'smart: * Unterminated statement'> ]
    {*}
}

##  terms
token term {
    | <value> {*}                                #= value
    | <makefile_variable_method_call> {*}        #= makefile_variable_method_call
    | <makefile_variable_ref> {*}		 #= makefile_variable_ref
}

rule value {
    | <integer> {*}                              #= integer
    | <quote> {*}                                #= quote
}

rule integer { \d+ {*} }

rule quote {
    [ \' <string_literal: '\'' > \' | \" <string_literal: '"' > \" ]
    {*}
}

rule makefile_variable_method_call {
    <makefile_variable_ref> '.' <ident>
        '(' [ <expression> [ ',' <expression> ]* ]?
        [ ')' || <.panic: "smart: * Require an ')' to terminate parameter list"> ]
    {*}
}

token makefile_variable_ref {
    [
    | <makefile_variable_ref1>
    | <makefile_variable_ref2>
    ]
    {*}
#    {{
#    $S0 = match.text()
#    say $S0
#    }}
}
token makefile_variable_ref1 {
    '$'
    [ '(' $<name>=[<-[ ) \n : = # ]>+]
    [ ')' || <.panic: "smart: * Makefile variable referencing expects ')'"> ]]
}
token makefile_variable_ref2 {
    '$'
    [ '{' $<name>=[<-[ } \n : = # ]>+]
    [ '}' || <.panic: "smart: * Makefile variable referencing expects '}'"> ]]
}

rule expression is optable { ... }



######################################################################
##  expressions and operators
proto 'term:'     is precedence('=')     is parsed(&term)      { ... }

## multiplicative operators
proto infix:<*>   is looser(term:)       is pirop('mul')     { ... }
proto infix:</>   is equiv(infix:<*>)    is pirop('div')     { ... }

## additive operators
proto infix:<+>   is looser(infix:<*>)   is pirop('add')     { ... }
proto infix:<->   is equiv(infix:<+>)    is pirop('sub')     { ... }
######################################################################

